#include <Wire.h>
#include <Servo.h>

#define BAUD 115200

#define PWM_CNT         8
#define ESC_1_CNT       4
#define ESC_2_CNT       4

#define MASTER_ADDRESS  4
#define ESC_1_ADDRESS   8
#define ESC_2_ADDRESS   16

// Stores 4 pwm values for continuous motor updates
int PWM_DATA[ESC_1_CNT];
// Indexing variable (stored for reuse)
int PWM_DATA_PTR = 0;
// Connected servos
Servo m1, m2, m3, m4; // TODO: #define the pin numbers for the two robots

void setup() {
  // Set PWMs to neutral
  for(; PWM_DATA_PTR < ESC_1_CNT; PWM_DATA_PTR++) {
    PWM_DATA[PWM_DATA_PTR] = 1500;
  }

  // Setup I2C
  Wire.begin(ESC_1_ADDRESS);
  Wire.onReceive(onReceive);
  Serial.begin(BAUD); // DEBUG
}

void loop() {
  // TODO: Continuous update motors here
}

// DEBUG
char* itos(int num) {
  char *str; 		//str is a pointer variable; it will hold numerical value returned by function
  char data[16]; //this array will hold the ASCII codes generated by the function
  char *ptr = (int)(&(data)); //ptr is pointer variable; it points myData[] array and holds its base address
  //now the pointer variable ptr holds the base address of myData[] array
  //Serial.println(x, HEX); // shows base address in numerical form of myData[] array

  str = itoa(num, ptr, 10);

  return str;
}

// For receiveing PWM values and control flags
void onReceive(int bytes) {
  byte motor_enable = Wire.read(); // Enable / Disable flag

  if(bytes == 1) return; // If enable flag only, skip PWM parsing
  
  // Parse PWM data
  for (; PWM_DATA_PTR < ESC_1_CNT; PWM_DATA_PTR++) {
    byte c = Wire.read();
    int to_pwm = (c * 4 + 1000); // Data sent as (0-250), convert to (1000-2000)
    if(motor_enable & (1 << PWM_DATA_PTR)) { // Check if motor is disabled
      to_pwm = 1500;
    }
    PWM_DATA[PWM_DATA_PTR] = to_pwm;
  }

  PWM_DATA_PTR = 0;
}